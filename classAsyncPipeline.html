<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>plugin: AsyncPipeline Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">plugin
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classAsyncPipeline-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AsyncPipeline Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="async__pipeline_8h_source.html">async_pipeline.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for AsyncPipeline:</div>
<div class="dyncontent">
<div class="center"><img src="classAsyncPipeline__coll__graph.png" border="0" usemap="#aAsyncPipeline_coll__map" alt="Collaboration graph"/></div>
<map name="aAsyncPipeline_coll__map" id="aAsyncPipeline_coll__map">
<area shape="rect" title=" " alt="" coords="25,124,139,151"/>
<area shape="rect" href="classPerformanceMetrics.html" title=" " alt="" coords="5,5,159,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab225689a144ac36495837fe50f774923"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsyncPipeline.html#ab225689a144ac36495837fe50f774923">AsyncPipeline</a> (std::unique_ptr&lt; <a class="el" href="classModelBase.html">ModelBase</a> &gt; &amp;&amp;modelInstance, const <a class="el" href="structModelConfig.html">ModelConfig</a> &amp;config, ov::Core &amp;core)</td></tr>
<tr class="separator:ab225689a144ac36495837fe50f774923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1931de9aa267540f071666974cc01154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsyncPipeline.html#a1931de9aa267540f071666974cc01154">waitForData</a> (bool shouldKeepOrder=true)</td></tr>
<tr class="separator:a1931de9aa267540f071666974cc01154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d995476be41c6f01b247b939808efb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsyncPipeline.html#a0d995476be41c6f01b247b939808efb9">isReadyToProcess</a> ()</td></tr>
<tr class="separator:a0d995476be41c6f01b247b939808efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32376cae26a82b2691e690a24e8f125a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsyncPipeline.html#a32376cae26a82b2691e690a24e8f125a">waitForTotalCompletion</a> ()</td></tr>
<tr class="separator:a32376cae26a82b2691e690a24e8f125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71167e09c505b3bc4eeda242bf241229"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsyncPipeline.html#a71167e09c505b3bc4eeda242bf241229">submitData</a> (const <a class="el" href="structInputData.html">InputData</a> &amp;inputData, const std::shared_ptr&lt; <a class="el" href="structMetaData.html">MetaData</a> &gt; &amp;metaData)</td></tr>
<tr class="separator:a71167e09c505b3bc4eeda242bf241229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4bb65861a3aa4e1fbb482716267355"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="structResultBase.html">ResultBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsyncPipeline.html#a7b4bb65861a3aa4e1fbb482716267355">getResult</a> (bool shouldKeepOrder=true)</td></tr>
<tr class="separator:a7b4bb65861a3aa4e1fbb482716267355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e737a5f01e61b84c6cb1c4624c1bfe6"><td class="memItemLeft" align="right" valign="top"><a id="a0e737a5f01e61b84c6cb1c4624c1bfe6"></a>
<a class="el" href="classPerformanceMetrics.html">PerformanceMetrics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInferenceMetircs</b> ()</td></tr>
<tr class="separator:a0e737a5f01e61b84c6cb1c4624c1bfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fd15553549922426cf882329c1b0b4"><td class="memItemLeft" align="right" valign="top"><a id="ad3fd15553549922426cf882329c1b0b4"></a>
<a class="el" href="classPerformanceMetrics.html">PerformanceMetrics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPreprocessMetrics</b> ()</td></tr>
<tr class="separator:ad3fd15553549922426cf882329c1b0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4452d817e82e92b1b1d420fe72d586c"><td class="memItemLeft" align="right" valign="top"><a id="ae4452d817e82e92b1b1d420fe72d586c"></a>
<a class="el" href="classPerformanceMetrics.html">PerformanceMetrics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPostprocessMetrics</b> ()</td></tr>
<tr class="separator:ae4452d817e82e92b1b1d420fe72d586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a834ae3d68f569ab115ede9e66740ff25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structInferenceResult.html">InferenceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAsyncPipeline.html#a834ae3d68f569ab115ede9e66740ff25">getInferenceResult</a> (bool shouldKeepOrder)</td></tr>
<tr class="separator:a834ae3d68f569ab115ede9e66740ff25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a63be1ff6ee563e51f529da374a0e2440"><td class="memItemLeft" align="right" valign="top"><a id="a63be1ff6ee563e51f529da374a0e2440"></a>
std::unique_ptr&lt; <a class="el" href="classRequestsPool.html">RequestsPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>requestsPool</b></td></tr>
<tr class="separator:a63be1ff6ee563e51f529da374a0e2440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff286f961e57ec6cd65fa740ef1f64f7"><td class="memItemLeft" align="right" valign="top"><a id="aff286f961e57ec6cd65fa740ef1f64f7"></a>
std::unordered_map&lt; int64_t, <a class="el" href="structInferenceResult.html">InferenceResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>completedInferenceResults</b></td></tr>
<tr class="separator:aff286f961e57ec6cd65fa740ef1f64f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d13333833877783d42b7bfdb8804c03"><td class="memItemLeft" align="right" valign="top"><a id="a8d13333833877783d42b7bfdb8804c03"></a>
ov::CompiledModel&#160;</td><td class="memItemRight" valign="bottom"><b>compiledModel</b></td></tr>
<tr class="separator:a8d13333833877783d42b7bfdb8804c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c18beac109377bf3dd5baf2584ec546"><td class="memItemLeft" align="right" valign="top"><a id="a4c18beac109377bf3dd5baf2584ec546"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>mtx</b></td></tr>
<tr class="separator:a4c18beac109377bf3dd5baf2584ec546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f3720e08f4fd038f987026f0cac8c7"><td class="memItemLeft" align="right" valign="top"><a id="a85f3720e08f4fd038f987026f0cac8c7"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>condVar</b></td></tr>
<tr class="separator:a85f3720e08f4fd038f987026f0cac8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3355f9a7a6abf503b18e350e85a5bac"><td class="memItemLeft" align="right" valign="top"><a id="af3355f9a7a6abf503b18e350e85a5bac"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>inputFrameId</b> = 0</td></tr>
<tr class="separator:af3355f9a7a6abf503b18e350e85a5bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7506c88ed90b991a77c1fba15937ce4"><td class="memItemLeft" align="right" valign="top"><a id="aa7506c88ed90b991a77c1fba15937ce4"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>outputFrameId</b> = 0</td></tr>
<tr class="separator:aa7506c88ed90b991a77c1fba15937ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1e70bf85069ef9fadfb6ea4359304e"><td class="memItemLeft" align="right" valign="top"><a id="a1c1e70bf85069ef9fadfb6ea4359304e"></a>
std::exception_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>callbackException</b> = nullptr</td></tr>
<tr class="separator:a1c1e70bf85069ef9fadfb6ea4359304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2fc2df1eb3cb195d6c63c20d0bd7ca"><td class="memItemLeft" align="right" valign="top"><a id="acf2fc2df1eb3cb195d6c63c20d0bd7ca"></a>
std::unique_ptr&lt; <a class="el" href="classModelBase.html">ModelBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>model</b></td></tr>
<tr class="separator:acf2fc2df1eb3cb195d6c63c20d0bd7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d95a1b2761aa4cba0f320d8e4ae0730"><td class="memItemLeft" align="right" valign="top"><a id="a3d95a1b2761aa4cba0f320d8e4ae0730"></a>
<a class="el" href="classPerformanceMetrics.html">PerformanceMetrics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>inferenceMetrics</b></td></tr>
<tr class="separator:a3d95a1b2761aa4cba0f320d8e4ae0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc9d9dca691d9487ff848d0148f9478"><td class="memItemLeft" align="right" valign="top"><a id="a7dc9d9dca691d9487ff848d0148f9478"></a>
<a class="el" href="classPerformanceMetrics.html">PerformanceMetrics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>preprocessMetrics</b></td></tr>
<tr class="separator:a7dc9d9dca691d9487ff848d0148f9478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5299278c49cd70319f63771dcbfa4fd"><td class="memItemLeft" align="right" valign="top"><a id="ad5299278c49cd70319f63771dcbfa4fd"></a>
<a class="el" href="classPerformanceMetrics.html">PerformanceMetrics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>postprocessMetrics</b></td></tr>
<tr class="separator:ad5299278c49cd70319f63771dcbfa4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is base class for asynchronous pipeline Derived classes should add functions for data submission and output processing </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab225689a144ac36495837fe50f774923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab225689a144ac36495837fe50f774923">&#9670;&nbsp;</a></span>AsyncPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AsyncPipeline::AsyncPipeline </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classModelBase.html">ModelBase</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>modelInstance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structModelConfig.html">ModelConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ov::Core &amp;&#160;</td>
          <td class="paramname"><em>core</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads model and performs required initialization </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modelInstance</td><td>pointer to model object. Object it points to should not be destroyed manually after passing pointer to this function. </td></tr>
    <tr><td class="paramname">config</td><td>- fine tuning configuration for model </td></tr>
    <tr><td class="paramname">core</td><td>- reference to ov::Core instance to use. If it is omitted, new instance of ov::Core will be created inside. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a834ae3d68f569ab115ede9e66740ff25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834ae3d68f569ab115ede9e66740ff25">&#9670;&nbsp;</a></span>getInferenceResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structInferenceResult.html">InferenceResult</a> AsyncPipeline::getInferenceResult </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldKeepOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns processed result, if available </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shouldKeepOrder</td><td>if true, function will return processed data sequentially, keeping original frames order (as they were submitted). Otherwise, function will return processed data in random order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structInferenceResult.html">InferenceResult</a> with processed information or empty <a class="el" href="structInferenceResult.html">InferenceResult</a> (with negative frameID) if there's no any results yet. </dd></dl>

</div>
</div>
<a id="a7b4bb65861a3aa4e1fbb482716267355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4bb65861a3aa4e1fbb482716267355">&#9670;&nbsp;</a></span>getResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="structResultBase.html">ResultBase</a> &gt; AsyncPipeline::getResult </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldKeepOrder</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets available data from the queue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shouldKeepOrder</td><td>if true, function will treat results as ready only if next sequential result (frame) is ready (so results can be extracted in the same order as they were submitted). Otherwise, function will return if any result is ready. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d995476be41c6f01b247b939808efb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d995476be41c6f01b247b939808efb9">&#9670;&nbsp;</a></span>isReadyToProcess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AsyncPipeline::isReadyToProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if there's available infer requests in the pool and next frame can be submitted for processing, false otherwise. </dd></dl>

</div>
</div>
<a id="a71167e09c505b3bc4eeda242bf241229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71167e09c505b3bc4eeda242bf241229">&#9670;&nbsp;</a></span>submitData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t AsyncPipeline::submitData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structInputData.html">InputData</a> &amp;&#160;</td>
          <td class="paramname"><em>inputData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structMetaData.html">MetaData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>metaData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Submits data to the model for inference </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputData</td><td>- input data to be submitted </td></tr>
    <tr><td class="paramname">metaData</td><td>- shared pointer to metadata container. Might be null. This pointer will be passed through pipeline and put to the final result structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if image cannot be scheduled for processing (there's no free InferRequest available). Otherwise returns unique sequential frame ID for this particular request. Same frame ID will be written in the result structure. </dd></dl>

</div>
</div>
<a id="a1931de9aa267540f071666974cc01154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1931de9aa267540f071666974cc01154">&#9670;&nbsp;</a></span>waitForData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AsyncPipeline::waitForData </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldKeepOrder</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until either output data becomes available or pipeline allows to submit more input data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shouldKeepOrder</td><td>if true, function will treat results as ready only if next sequential result (frame) is ready (so results can be extracted in the same order as they were submitted). Otherwise, function will return if any result is ready. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32376cae26a82b2691e690a24e8f125a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32376cae26a82b2691e690a24e8f125a">&#9670;&nbsp;</a></span>waitForTotalCompletion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AsyncPipeline::waitForTotalCompletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits for all currently submitted requests to be completed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/common/pipelines/include/pipelines/<a class="el" href="async__pipeline_8h_source.html">async_pipeline.h</a></li>
<li>src/common/pipelines/src/async_pipeline.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
